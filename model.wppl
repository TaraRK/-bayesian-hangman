// Helper function to compute letter frequencies in English
var letterFrequencies = json.read('letter_freq.json');
var wordFreq = json.read('freq_dict.json');
var dictionary = Object.keys(wordFreq);


// Basic model
var simpleModel = function() {
  // Just try to learn weights between frequency and random
  var modelChoice = sample(Categorical(({ps: [0.25, 0.25, 0.25], vs: [1, 2, 3]})));

  mapData({data: data}, function(game) {
    var availableLetters = filter(
      function(l) { return !game.previousGuesses.includes(l) },
      Object.keys(letterFrequencies)
    )
    
    // Choose distribution based on strategy
    if (modelChoice === 1) {
      // Use letter frequencies
      var freqSum = sum(map(function(l) { 
        return letterFrequencies[l]
      }, availableLetters))
      
      var probs = map(function(l) { 
        return letterFrequencies[l] / freqSum
      }, availableLetters)
      
      observe(Categorical(({vs: availableLetters, ps: probs})), game.actualGuess)
    } else if (modelChoice === 2) {
      // Use random guessing
      observe(
        Categorical({
          vs: availableLetters, 
          ps: repeat(availableLetters.length, function() { 
            return 1/availableLetters.length 
          })
        }),
        game.actualGuess
      )
    } else if (modelChoice === 3) {
      // Bayesian approach with uniform weighting over words that match the pattern
      // 1. Identify possible words
      var pattern = game.pattern;
      var previousGuesses = game.previousGuesses;
    
      // Function to check if a word matches the pattern and guesses
      var matchesPattern = function(pattern, word, previousGuesses) {
        if (word.length !== pattern.length) {
          return false;
        }
    
        // Determine confirmed present letters (non-underscore in pattern)
        var confirmedPresent = [];
        for (var i = 0; i < pattern.length; i++) {
          if (pattern[i] !== '_') {
            confirmedPresent.push(pattern[i]);
          }
        }
    
        // Determine confirmed absent letters (guessed but not present)
        var confirmedAbsent = [];
        for (var j = 0; j < previousGuesses.length; j++) {
          var gChar = previousGuesses[j];
          // If guessed letter not in pattern or not confirmed present, consider absent
          if (pattern.indexOf(gChar) === -1 || confirmedPresent.indexOf(gChar) === -1) {
            confirmedAbsent.push(gChar);
          }
        }
    
        // Check pattern constraints
        for (var k = 0; k < pattern.length; k++) {
          var pChar = pattern[k];
          var wChar = word[k];
          if (pChar !== '_' && pChar !== wChar) {
            return false;
          }
        }
    
        // Check absence constraints
        for (var m = 0; m < confirmedAbsent.length; m++) {
          if (word.indexOf(confirmedAbsent[m]) !== -1) {
            return false;
          }
        }
    
        return true;
      };
    
      // Get possible words from the dictionary
      var possibleWords = filter(function(w) {
        return matchesPattern(pattern, w, previousGuesses);
      }, dictionary);
    
      // 2. Compute letter probabilities
      var notGuessedLetters = filter(function(l) {
        return previousGuesses.indexOf(l) === -1;
      }, 'abcdefghijklmnopqrstuvwxyz'.split(''));
    
      // Count how often each letter appears in underscore positions
      var letterCounts = {};
      for (var i = 0; i < notGuessedLetters.length; i++) {
        letterCounts[notGuessedLetters[i]] = 0;
      }
    
      // For each possible word, increment counts for letters in underscore positions
      // Weight is uniform, so each word contributes equally
      // for (var wIdx = 0; wIdx < possibleWords.length; wIdx++) {
      //   var w = possibleWords[wIdx];
      //   for (var pos = 0; pos < w.length; pos++) {
      //     if (pattern[pos] === '_') {
      //       var letter = w[pos];
      //       if (notGuessedLetters.indexOf(letter) !== -1) {
      //         letterCounts[letter] = letterCounts[letter] + 1;
      //       }
      //     }
      //   }
      // }
    
      // 3. Convert counts to probabilities
      // var total = 0;
      // for (var lIdx = 0; lIdx < notGuessedLetters.length; lIdx++) {
      //   total += letterCounts[notGuessedLetters[lIdx]];
      // }

    
      var finalLetters = ["a"];
      var finalProbs = [1];
      
      // for (var lIdx2 = 0; lIdx2 < notGuessedLetters.length; lIdx2++) {
      //   var letter2 = notGuessedLetters[lIdx2];
      //   // if (letterCounts[letter2] > 0) {
      //   finalLetters.push(letter2);
      //   finalProbs.push(letterCounts[letter2] / total);
      //   // }
      // }
    
      observe(Categorical(({vs: finalLetters, ps: finalProbs})), game.actualGuess);
    }
    
    
  })
  
  return useFrequency
}

var data = [{
  pattern: "h_ll_",
  previousGuesses: ['h', 'l'],
  actualGuess: 'e'
}]

var posterior = Infer({
  method: 'MCMC',
  samples: 1000,
  model: simpleModel
})


expectation(posterior, function(x) { return x ? 1 : 0 })

    