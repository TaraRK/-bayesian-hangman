// model3.wppl




var letterFrequencies = json.read('letter_freq.json');
var wordFreq = json.read('word_freq.json');
var dictionary = Object.keys(wordFreq);

var simpleModel = function() {
  // Just try to learn weights between frequency and random
  var modelChoice = sample(Categorical({ps: [0.25, 0.25, 0.25, 0.25], vs: [1, 2, 3, 4]}));

  mapData({data: data}, function(game) {
    var allLetters = Object.keys(letterFrequencies);
    var availableLetters = filter(function(l){ 
      return game.previousGuesses.indexOf(l) === -1; 
    }, allLetters);

    if (modelChoice === 1) {
      var uniformProb = 1/availableLetters.length;
      var uniformPs = repeat(availableLetters.length, function(){return uniformProb;});
      observe(Categorical({vs: availableLetters, ps: uniformPs}), game.actualGuess);
      
    } else if (modelChoice === 2) {
      var freqs = map(function(l){ return letterFrequencies[l]; }, availableLetters);
      var freqSum = sum(freqs);
      var probs = map(function(x){ return x/freqSum; }, freqs);
      observe(Categorical({vs: availableLetters, ps: probs}), game.actualGuess);

    } else if (modelChoice === 3) {
      var correctGuesses = filter(function(g){return game.word.indexOf(g) > -1;}, game.previousGuesses);
      var incorrectGuesses = filter(function(g){return game.word.indexOf(g) === -1;}, game.previousGuesses);
      var pattern = {
        partial: game.partialWordPattern,
        in: correctGuesses,
        not_in: incorrectGuesses
      };

      // letter_inference function assumed to be available from a header
      var letterProbsObj = webpplPackageTemplate.letter_inference(pattern, false); 
      var possibleLetters3 = Object.keys(letterProbsObj);
      var filteredLetters = filter(function(l){return letterProbsObj[l] > 0;}, possibleLetters3);
      var letterPs = map(function(l){return letterProbsObj[l];}, filteredLetters);

      var pSum = sum(letterPs);
      var normLetterPs = map(function(p){return p/pSum;}, letterPs);

      observe(Categorical({vs: filteredLetters, ps: normLetterPs}), game.actualGuess);
    } else if (modelChoice === 4) {
      var correctGuesses = filter(function(g){return game.word.indexOf(g) > -1;}, game.previousGuesses);
      var incorrectGuesses = filter(function(g){return game.word.indexOf(g) === -1;}, game.previousGuesses);
      var pattern = {
        partial: game.partialWordPattern,
        in: correctGuesses,
        not_in: incorrectGuesses
      };

      // letter_inference function assumed to be available from a header
      var letterProbsObj = webpplPackageTemplate.letter_inference(pattern, true); 
      var possibleLetters3 = Object.keys(letterProbsObj);
      var filteredLetters = filter(function(l){return letterProbsObj[l] > 0;}, possibleLetters3);
      var letterPs = map(function(l){return letterProbsObj[l];}, filteredLetters);

      var pSum = sum(letterPs);
      var normLetterPs = map(function(p){return p/pSum;}, letterPs);

      observe(Categorical({vs: filteredLetters, ps: normLetterPs}), game.actualGuess);
    }

  });

  return modelChoice;
};


var partial = ["_", "o", "_", "_", "e", "_", "_", "_", "_"]
var in_letters = ["o", "e"]
var not_in_letters = ["s"]
var previousGuesses = in_letters.concat(not_in_letters)

// var data = [
//   {
//     previousGuesses: previousGuesses,
//     actualGuess: "l",
//     partialWordPattern: partial,
//     word: "wonderful"
//   },
// ]

//import data from 'data.js'
var data = json.read('data.js');


var x = webpplPackageTemplate.letter_inference({ partial: partial, in: in_letters, not_in: not_in_letters }, false)
console.log(x)

var posterior = Infer({
  method: 'MCMC',
  samples: 10000,
  model: simpleModel
})


var probModel1 = expectation(posterior, function(x) { return x === 1 ? 1 : 0 });
var probModel2 = expectation(posterior, function(x) { return x === 2 ? 1 : 0 });
var probModel3 = expectation(posterior, function(x) { return x === 3 ? 1 : 0 });
var probModel4 = expectation(posterior, function(x) { return x === 4 ? 1 : 0 });



console.log({
  random_guess_model: probModel1,
  letter_freq_model: probModel2,
  dict_model: probModel3, 
  bayesian_model: probModel4, 
});
    