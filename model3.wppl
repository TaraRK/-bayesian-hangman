// model3.wppl
console.log(pack.myAdd(1, 2));

// var x = bayesianHangman.letter_inference({partial:["_"], in:[], not_in:[]}, false);
// print(x);




// var letterFrequencies = json.read('letter_freq.json');
// var wordFreq = json.read('word_freq.json');
// var dictionary = Object.keys(wordFreq);

// var simpleModel = function() {
//   // Just try to learn weights between frequency and random
//   var modelChoice = sample(Categorical({ps: [0.25, 0.25, 0.25], vs: [1, 2, 3]}));

//   mapData({data: data}, function(game) {
//     var allLetters = Object.keys(letterFrequencies);
//     var availableLetters = filter(function(l){ 
//       return game.previousGuesses.indexOf(l) === -1; 
//     }, allLetters);

//     if (modelChoice === 1) {
//       var freqs = map(function(l){ return letterFrequencies[l]; }, availableLetters);
//       var freqSum = sum(freqs);
//       var probs = map(function(x){ return x/freqSum; }, freqs);
//       observe(Categorical({vs: availableLetters, ps: probs}), game.actualGuess);

//     } else if (modelChoice === 2) {
//       var uniformProb = 1/availableLetters.length;
//       var uniformPs = repeat(availableLetters.length, function(){return uniformProb;});
//       observe(Categorical({vs: availableLetters, ps: uniformPs}), game.actualGuess);

//     } else if (modelChoice === 3) {
//       var correctGuesses = filter(function(g){return game.word.indexOf(g) > -1;}, game.previousGuesses);
//       var incorrectGuesses = filter(function(g){return game.word.indexOf(g) === -1;}, game.previousGuesses);
//       var pattern = {
//         partial: game.partialWordPattern,
//         in: correctGuesses,
//         not_in: incorrectGuesses
//       };

//       // letter_inference function assumed to be available from a header
//       var letterProbsObj = letter_inference(pattern, false); 
//       var possibleLetters3 = Object.keys(letterProbsObj);
//       var filteredLetters = filter(function(l){return letterProbsObj[l] > 0;}, possibleLetters3);
//       var letterPs = map(function(l){return letterProbsObj[l];}, filteredLetters);

//       var pSum = sum(letterPs);
//       var normLetterPs = map(function(p){return p/pSum;}, letterPs);

//       observe(Categorical({vs: filteredLetters, ps: normLetterPs}), game.actualGuess);
//     }
//   });

//   return modelChoice;
// };

// // // Now run inference on the simpleModel
// // var posterior = Infer({method: "MCMC", samples: 1000}, simpleModel);
// // viz(posterior);




// var data = [{
//   pattern: "h_ll_",
//   previousGuesses: ['h', 'l'],
//   word: "hello",
//   actualGuess: 'e'
// }]

// var posterior = Infer({
//   method: 'MCMC',
//   samples: 1000,
//   model: simpleModel
// })


// expectation(posterior, function(x) { return x ? 1 : 0 })

    